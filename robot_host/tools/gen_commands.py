#!/usr/bin/env python3
"""
Generate command schema artifacts from platform_schema.COMMANDS.
"""
from typing import Any
from pathlib import Path
import json
from platform_schema import ROOT, COMMANDS, VERSION

JSON_OUT = Path("/Users/kwasiaddo/projects/Host/robot_host/config/commands.json")
CPP_OUT = Path("/Users/kwasiaddo/projects/PlatformIO/Projects/ESP32 MCU Host/include/config/CommandDefs.h")
CPP_VERSION_OUT = Path("/Users/kwasiaddo/projects/ESP32 MCU Host/include/config/Version.h")   
PY_VERSION_OUT = Path("/Users/kwasiaddo/projects/Host/robot_host/config/version.py")   
PY_OUT = Path("/Users/kwasiaddo/projects/Host/robot_host/config/command_defs.py")
PY_CLIENT_MIXIN_OUT = Path("/Users/kwasiaddo/projects/Host/robot_host/config/client_commands.py")
SCHEMA_VERSION = 1


def validate_commands(cmds: dict) -> None:
    for name, spec in cmds.items():
        if not name.startswith("CMD_"):
            raise ValueError(f"Command name '{name}' must start with 'CMD_'")

        kind = spec.get("kind")
        if kind not in ("cmd", "telemetry", "event", "resp", "error"):
            raise ValueError(f"{name}: invalid kind '{kind}'")

        direction = spec.get("direction")
        if direction not in ("host->mcu", "mcu->host", "both"):
            raise ValueError(
                f"{name}: direction must be 'host->mcu', 'mcu->host', or 'both'"
            )

        payload = spec.get("payload")
        if not isinstance(payload, dict):
            raise ValueError(f"{name}: payload must be an object (dict)")

        for field_name, field_spec in payload.items():
            if not isinstance(field_spec, dict):
                raise ValueError(f"{name}.{field_name}: field spec must be an object")
            if "type" not in field_spec:
                raise ValueError(f"{name}.{field_name}: field must define 'type'")


def generate_json(commands: dict) -> str:
    data = {
        "commands": commands,
        "schema_version": SCHEMA_VERSION,
    }
    return json.dumps(data, indent=2)


def generate_cpp_header(commands: dict) -> str:
    names = sorted(commands.keys())
    enum_entries = [name.replace("CMD_", "") for name in names]

    lines: list[str] = []
    lines.append("// AUTO-GENERATED FILE — DO NOT EDIT BY HAND")
    lines.append("// Generated from COMMANDS in platform_schema.py\n")
    lines.append("#pragma once")
    lines.append("#include <string>\n")
    lines.append("enum class CmdType {")
    for entry in enum_entries:
        lines.append(f"    {entry},")
    lines.append("    UNKNOWN")
    lines.append("};\n")

    lines.append("inline CmdType cmdTypeFromString(const std::string& s) {")
    for name, entry in zip(names, enum_entries):
        lines.append(f'    if (s == "{name}") return CmdType::{entry};')
    lines.append("    return CmdType::UNKNOWN;")
    lines.append("}\n")

    lines.append("inline const char* cmdTypeToString(CmdType c) {")
    lines.append("    switch (c) {")
    for name, entry in zip(names, enum_entries):
        lines.append(f'        case CmdType::{entry}: return "{name}";')
    lines.append('        default: return "UNKNOWN";')
    lines.append("    }")
    lines.append("}\n")

    return "\n".join(lines)


def generate_py_module(commands: dict) -> str:
    names = sorted(commands.keys())

    lines: list[str] = []
    lines.append("# AUTO-GENERATED FILE — DO NOT EDIT BY HAND")
    lines.append("# Generated from COMMANDS in platform_schema.py\n")

    for name in names:
        lines.append(f'{name} = "{name}"')

    lines.append("\nALL_COMMANDS = [")
    for name in names:
        lines.append(f"    {name},")
    lines.append("]\n")

    return "\n".join(lines)


def python_type_for(field: dict[str, Any]) -> str:
    t = field.get("type", "any")
    if t == "int":
        return "int"
    if t == "float":
        return "float"
    if t == "string":
        return "str"
    if t == "bool":
        return "bool"
    return "Any"


def write_python_client_mixin(commands: dict[str, dict]) -> str:
    lines: list[str] = []
    lines.append("# AUTO-GENERATED BY gen_commands.py — DO NOT EDIT.\n\n")
    lines.append("from __future__ import annotations\n")
    lines.append("from typing import Any, Optional\n\n\n")
    lines.append("class RobotCommandsMixin:\n")
    lines.append('    """\n')
    lines.append("    Auto-generated high-level JSON command helpers.\n")
    lines.append("    Requires that the inheriting client defines:\n")
    lines.append("        async def send_json_cmd(self, type_str: str, payload: dict | None = None) -> None\n")
    lines.append('    """\n')

    for cmd_name, spec in commands.items():
        if spec.get("kind") != "cmd":
            continue

        payload_spec: dict[str, dict] = spec.get("payload", {}) or {}
        description: str = spec.get("description", "").strip()

        if cmd_name.startswith("CMD_"):
            base = cmd_name[4:].lower()
        else:
            base = cmd_name.lower()
        method_name = f"cmd_{base}"

        required_args: list[tuple[str, str]] = []
        optional_args: list[tuple[str, str, Any, bool]] = []

        for field_name, field_meta in payload_spec.items():
            py_type = python_type_for(field_meta)
            required = field_meta.get("required", False)
            has_default = "default" in field_meta
            default = field_meta.get("default", None)

            if required and not has_default:
                required_args.append((field_name, py_type))
            else:
                optional_args.append((field_name, py_type, default, has_default))

        sig_parts: list[str] = ["self"]
        for name, t in required_args:
            sig_parts.append(f"{name}: {t}")
        for name, t, default, has_default in optional_args:
            if has_default:
                sig_parts.append(f"{name}: {t} = {repr(default)}")
            else:
                sig_parts.append(f"{name}: Optional[{t}] = None")

        sig = ", ".join(sig_parts)

        lines.append(f"    async def {method_name}({sig}) -> None:\n")
        if description:
            lines.append(f'        """{description} ({cmd_name})"""\n')
        else:
            lines.append(f'        """Auto-generated helper for {cmd_name}."""\n')

        if payload_spec:
            lines.append("        payload: dict[str, Any] = {}\n")
            for name, _ in required_args:
                lines.append(f"        payload['{name}'] = {name}\n")
            for name, _, default, has_default in optional_args:
                if has_default:
                    lines.append(f"        payload['{name}'] = {name}\n")
                else:
                    lines.append(f"        if {name} is not None:\n")
                    lines.append(f"            payload['{name}'] = {name}\n")
        else:
            lines.append("        payload: dict[str, Any] = {}\n")

        lines.append(f"        await self.send_json_cmd('{cmd_name}', payload)\n\n")

    return "".join(lines)


# -----------------------------------------------------------------------------
# Version file generation
# -----------------------------------------------------------------------------

def generate_cpp_version(version: dict) -> str:
    """Generate C++ Version.h content."""
    return f'''// AUTO-GENERATED FILE — DO NOT EDIT BY HAND
// Generated from VERSION in platform_schema.py

#pragma once

namespace Version {{
    constexpr const char* FIRMWARE = "{version["firmware"]}";
    constexpr uint8_t PROTOCOL = {version["protocol"]};
    constexpr const char* BOARD = "{version["board"]}";
    constexpr const char* NAME = "{version["name"]}";
}}
'''


def generate_py_version(version: dict) -> str:
    """Generate Python version.py content."""
    return f'''# AUTO-GENERATED FILE — DO NOT EDIT BY HAND
# Generated from VERSION in platform_schema.py

PROTOCOL_VERSION = {version["protocol"]}
CLIENT_VERSION = "{version["firmware"]}"
BOARD = "{version["board"]}"
NAME = "{version["name"]}"
'''


def write_version_files(version: dict, cpp_path: Path, py_path: Path) -> None:
    """Write version files for both firmware and host."""
    cpp_content = generate_cpp_version(version)
    cpp_path.parent.mkdir(parents=True, exist_ok=True)
    cpp_path.write_text(cpp_content, encoding="utf-8")
    print(f"[gen_commands] Wrote {cpp_path}")

    py_content = generate_py_version(version)
    py_path.parent.mkdir(parents=True, exist_ok=True)
    py_path.write_text(py_content, encoding="utf-8")
    print(f"[gen_commands] Wrote {py_path}")


# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

def main():
    print("[gen_commands] Validating COMMANDS...")
    validate_commands(COMMANDS)

    print(f"[gen_commands] Generating JSON: {JSON_OUT}")
    json_text = generate_json(COMMANDS)

    print(f"[gen_commands] Generating C++ header: {CPP_OUT}")
    cpp_code = generate_cpp_header(COMMANDS)

    print(f"[gen_commands] Generating Python module: {PY_OUT}")
    py_code = generate_py_module(COMMANDS)

    print(f"[gen_commands] Generating Python client mixin: {PY_CLIENT_MIXIN_OUT}")
    py_client_code = write_python_client_mixin(COMMANDS)

    # Write command files
    JSON_OUT.parent.mkdir(parents=True, exist_ok=True)
    CPP_OUT.parent.mkdir(parents=True, exist_ok=True)
    PY_OUT.parent.mkdir(parents=True, exist_ok=True)

    JSON_OUT.write_text(json_text, encoding="utf-8")
    CPP_OUT.write_text(cpp_code, encoding="utf-8")
    PY_OUT.write_text(py_code, encoding="utf-8")
    PY_CLIENT_MIXIN_OUT.write_text(py_client_code, encoding="utf-8")

    # Write version files
    print(f"[gen_commands] Generating C++ version: {CPP_VERSION_OUT}")
    print(f"[gen_commands] Generating Python version: {PY_VERSION_OUT}")
    write_version_files(VERSION, CPP_VERSION_OUT, PY_VERSION_OUT)

    print("[gen_commands] Done.")


if __name__ == "__main__":
    main()