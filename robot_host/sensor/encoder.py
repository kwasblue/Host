from __future__ import annotations

from dataclasses import dataclass
from typing import Any

from robot_host.command.client import AsyncRobotClient 
from robot_host.core.event_bus import EventBus
from robot_host.config.pin_config import ENC0_A, ENC0_B


@dataclass
class EncoderDefaults:
    encoder_id: int = 0
    pin_a: int = ENC0_A
    pin_b: int = ENC0_B


class EncoderHostModule:
    """
    Host-side wrapper around encoder commands.
    Wraps CMD_ENCODER_ATTACH / CMD_ENCODER_READ / CMD_ENCODER_RESET,
    using the generated cmd_encoder_* methods on AsyncRobotClient.
    """

    def __init__(
        self,
        bus: EventBus,
        client: AsyncRobotClient,
        defaults: EncoderDefaults | None = None,
    ) -> None:
        self._bus = bus
        self._client = client
        self._defaults = defaults or EncoderDefaults()

    async def attach(
        self,
        encoder_id: int | None = None,
        pin_a: int | None = None,
        pin_b: int | None = None,
    ) -> None:
        eid = encoder_id if encoder_id is not None else self._defaults.encoder_id
        pa  = pin_a if pin_a is not None else self._defaults.pin_a
        pb  = pin_b if pin_b is not None else self._defaults.pin_b

        # Use the autogenerated helper instead of hardcoding CMD_*:
        await self._client.cmd_encoder_attach(
            encoder_id=eid,
            pin_a=pa,
            pin_b=pb,
        )

    async def read(self, encoder_id: int | None = None) -> None:
        eid = encoder_id if encoder_id is not None else self._defaults.encoder_id
        await self._client.cmd_encoder_read(encoder_id=eid)

    async def reset(self, encoder_id: int | None = None) -> None:
        eid = encoder_id if encoder_id is not None else self._defaults.encoder_id
        await self._client.cmd_encoder_reset(encoder_id=eid)
